= Events =
{{{
// Main include of the library
#include <UtiLite.h>

// Create a custom event.
// The pure virtual method "getClassName()" of UEvent 
// must be redefined by inherited classes and populated 
// with their exact name. The name can be then used to 
// determine the concrete class of an UEvent.
class SpecialEvent : public UEvent {
public:
   SpecialEvent(int code) : UEvent(code) {}
   ~SpecialEvent() {}

   virtual std::string getClassName() const {
	   return "SpecialEvent";
   }
};

// Create a simple events handler.
// The pure virtual method "handleEvent(UEvent*)" must 
// be redefined by inherited classes of UEventsHandler. This 
// method will be called each time a new event is posted to the 
// EventsManager. Since we receive all events, here we compare 
// the UEvent class name with the one we want to handle (the SpecialEvent).
class EventsPrinter : public UEventsHandler
{
public:
   EventsPrinter() {}
   ~EventsPrinter() {}

protected:
   virtual void handleEvent(UEvent * e) {
      if(e->getClassName().compare("SpecialEvent") == 0) {
         ULOGGER_INFO("SpecialEvent \"%d\" received!", e->getCode());
      }
   }
};

int main(int argc, char * argv[])
{
   // Set the logger type. The choices are kTypeConsole,
   // kTypeFile or kTypeNoLog (nothing is logged).
   ULogger::setType(ULogger::kTypeConsole);

   // Set the logger severity level (kDebug, kInfo, kWarning, kError).
   // All log entries under the severity level are not logged. Here,
   // only debug messages are not logged.
   ULogger::setLevel(ULogger::kInfo);

   // Use a predefined Macro to easy logging. It can be
   // called anywhere in the application as the logger is
   // a Singleton.
   ULOGGER_DEBUG("This message won't be logged because the "
                 "severity level of the logger is set to kInfo.");
   ULOGGER_INFO("This message is logged.");

   // Lets create a simple EventsPrinter that will log all
   // events it will received.
   EventsPrinter p;

   // Register the EventsPrinter to the EventsManager to
   // receive events posted in the application.
   UEventsManager::addHandler(&p);

   // Post some events. As ULogger, UEventsManager
   // is a Singleton and posting events is ThreadSafe.
   UEventsManager::post(new SpecialEvent(1));
   UEventsManager::post(new SpecialEvent(2));
   UEventsManager::post(new SpecialEvent(5));
   UEventsManager::post(new SpecialEvent(7));
   UEventsManager::post(new SpecialEvent(11));

   // Let some times to process the events and quit.
   uSleep(10);

   // Cleanup
   UEventsManager::removeHandler(&p);

   return 0;
}
}}}

Output :
{{{
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:53::main() This message is logged.
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "1" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "2" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "5" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "7" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "11" received!
}}}

= UThreadNode =
todo...

= ULogger =
todo...