#summary Here is some examples of what can be done by the library.
<wiki:toc max_depth="1" />
= Events =
Note : the communication used between threads is events-based.

Output :
{{{
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:53::main() This message is logged.
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "1" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "2" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "5" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "7" received!
[ INFO] (2010-09-25 18:08:20) eventsExample.cpp:32::handleEvent() SpecialEvent "11" received!
}}}

Code :
{{{
// Main include of the library
#include <utilite/UtiLite.h>

// Create a custom event.
// The pure virtual method "getClassName()" of UEvent 
// must be redefined by inherited classes and populated 
// with their exact name. The name can be then used to 
// determine the concrete class of an UEvent.
class SpecialEvent : public UEvent {
public:
   SpecialEvent(int code) : UEvent(code) {}
   ~SpecialEvent() {}

   virtual std::string getClassName() const {
      return "SpecialEvent";
   }
};

// Create a simple events handler.
// The pure virtual method "handleEvent(UEvent*)" must 
// be redefined by inherited classes of UEventsHandler. This 
// method will be called each time a new event is posted to the 
// EventsManager. Since we receive all events, here we compare 
// the UEvent class name with the one we want to handle (the SpecialEvent).
class EventsPrinter : public UEventsHandler
{
public:
   EventsPrinter() {}
   ~EventsPrinter() {}

protected:
   virtual void handleEvent(UEvent * e) {
      if(e->getClassName().compare("SpecialEvent") == 0) {
         ULOGGER_INFO("SpecialEvent \"%d\" received!", e->getCode());
      }
   }
};

int main(int argc, char * argv[])
{
   // Set the logger type. The choices are kTypeConsole,
   // kTypeFile or kTypeNoLog (nothing is logged).
   ULogger::setType(ULogger::kTypeConsole);

   // Set the logger severity level (kDebug, kInfo, kWarning, kError).
   // All log entries under the severity level are not logged. Here,
   // only debug messages are not logged.
   ULogger::setLevel(ULogger::kInfo);

   // Use a predefined Macro to easy logging. It can be
   // called anywhere in the application as the logger is
   // a Singleton.
   ULOGGER_DEBUG("This message won't be logged because the "
                 "severity level of the logger is set to kInfo.");
   ULOGGER_INFO("This message is logged.");

   // Let's create a simple EventsPrinter that will log all
   // events it will received.
   EventsPrinter p;

   // Register the EventsPrinter to the EventsManager to
   // receive events posted in the application.
   UEventsManager::addHandler(&p);

   // Post some events. As ULogger, UEventsManager
   // is a Singleton and posting events is ThreadSafe.
   UEventsManager::post(new SpecialEvent(1));
   UEventsManager::post(new SpecialEvent(2));
   UEventsManager::post(new SpecialEvent(5));
   UEventsManager::post(new SpecialEvent(7));
   UEventsManager::post(new SpecialEvent(11));

   // Let some times to process the events and quit.
   uSleep(10);

   // Cleanup
   UEventsManager::removeHandler(&p);

   return 0;
}
}}}

= UThreadNode =
Output :
{{{
Example with the UThreadNode class

This is called once before entering the main thread loop.
This is the loop 1...
This is the loop 2...
This thread will now wait on a semaphore...
Releasing the semaphore...
Thread woke up!
SimpleThread destructor
}}}
Code :
{{{
#include <utilite/UThreadNode.h>
#include <stdio.h>

class SimpleThread : public UThreadNode
{
public:
   SimpleThread() : loopCount_(0) {}
   ~SimpleThread() {
      printf("SimpleThread destructor\n");
      this->kill();
   }

protected:
   virtual void startInit() {
      printf("This is called once before entering the main thread loop.\n");
      loopCount_ = 1;
   }

   virtual void mainLoop() {
      if(loopCount_ < 3) {
         printf("This is the loop %d...\n", loopCount_++);
         uSleep(10);
      }
      else {
         printf("This thread will now wait on a semaphore...\n");
         semaphore_.acquire();
         printf("Thread woke up!\n");
      }
   }

   virtual void killCleanup() {
      printf("Releasing the semaphore...\n");
      semaphore_.release();
   }
private:
   int loopCount_;
   USemaphore semaphore_;
};

int main(int argc, char * argv[])
{
   SimpleThread t;
   printf("Example with the StateThread class\n\n");
   t.start();
   uSleep(100);
   t.kill();
   return 0;
}
}}}

= Producer-Consumer problem =
Output :
{{{
[ INFO] (2010-12-21 15:58:23) p500 posting 0
[ INFO] (2010-12-21 15:58:23) p1000 posting 0
[ INFO] (2010-12-21 15:58:23) Consumer received 0
[ INFO] (2010-12-21 15:58:23) Consumer received 0
[ INFO] (2010-12-21 15:58:23) p500 posting 1
[ INFO] (2010-12-21 15:58:23) Consumer received 1
[ INFO] (2010-12-21 15:58:24) p1000 posting 1
[ INFO] (2010-12-21 15:58:24) Consumer received 1
[ INFO] (2010-12-21 15:58:24) p500 posting 2
[ INFO] (2010-12-21 15:58:24) Consumer received 2
[ INFO] (2010-12-21 15:58:24) p500 posting 3
[ INFO] (2010-12-21 15:58:24) Consumer received 3
[ INFO] (2010-12-21 15:58:25) p1000 posting 2
[ INFO] (2010-12-21 15:58:25) Consumer received 2
[ INFO] (2010-12-21 15:58:25) p500 posting 4
[ INFO] (2010-12-21 15:58:25) Consumer received 4
[ INFO] (2010-12-21 15:58:25) p500 posting 5
[ INFO] (2010-12-21 15:58:25) Consumer received 5
[ INFO] (2010-12-21 15:58:26) p1000 posting 3
[ INFO] (2010-12-21 15:58:26) Consumer received 3
[ INFO] (2010-12-21 15:58:26) p500 posting 6
[ INFO] (2010-12-21 15:58:26) Consumer received 6
[ INFO] (2010-12-21 15:58:26) p500 posting 7
[ INFO] (2010-12-21 15:58:26) Consumer received 7
}}}

Code :
{{{
#include <utilite/UThreadNode.h>
#include <utilite/UEventsHandler.h>
#include <utilite/ULogger.h>
#include <utilite/UEvent.h>
#include <utilite/UEventsManager.h>

/**
 * Example of the producer-consumer problem.
 */

// The Producer class
class Producer : public UThreadNode
{
public:
   Producer(const std::string & name, int ms) :
      name_(name),
      rate_(ms) ,
      count_(0) {}

   ~Producer() {
      this->kill();
   }

protected:
   virtual void mainLoop() {
      UINFO("%s posting %d", name_.c_str(), count_);
      UEventsManager::post(new UEvent(count_++));
      uSleep(rate_);
   }

private:
   const std::string name_;
   int rate_;
   int count_;
};

// The Consumer class
class Consumer : public UEventsHandler
{
public:
   Consumer() {}
   ~Consumer() {}

protected:
   virtual void handleEvent(UEvent * event) {
      UINFO("Consumer received %d", event->getCode());
   }
};

int main(int argc, char * argv[])
{
   ULogger::setType(ULogger::kTypeConsole);
   ULogger::setPrintWhere(false);

   Consumer c;
   UEventsManager::addHandler(&c);

   Producer p500("p500", 500); //post each 500 ms
   Producer p1000("p1000", 1000); //post each 1000 ms

   // Start the producer threads
   p500.start();
   p1000.start();

   uSleep(3500);
   return 0;
}
}}}